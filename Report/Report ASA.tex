% LaTeX Template for short student reports.
% Citations should be in bibtex format and go in references.bib
\documentclass[a4paper, 11pt]{article}
\usepackage[top=3cm, bottom=3cm, left = 2cm, right = 2cm]{geometry} 
\geometry{a4paper} 
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{graphicx} 
\usepackage{amsmath,amssymb}  
\usepackage{bm}  
\usepackage[pdftex,bookmarks,colorlinks,breaklinks]{hyperref}  
\hypersetup{linkcolor=black,citecolor=black,filecolor=black,urlcolor=black} % black links, for printed output
\usepackage{memhfixc} 
\usepackage{pdfsync}  
\usepackage{fancyhdr}
\pagestyle{fancy}

\title{\Huge{Autonomous Software Agents} \\ \Large{Project Report} }

\author{
\begin{tabular}{ccc}
\parbox{7cm}{\centering Francesco Vaccari [239927] \\ \small{\centering francesco.vaccari@studenti.unitn.it}} & 
\parbox{1cm}{\centering \footnotesize{AGVZZ Group}} & 
\parbox{7cm}{\centering Simone Compri [239953] \\ \small{\centering simone.compri@studenti.unitn.it}}
\end{tabular}
}

\date{}

\begin{document}
\maketitle
\tableofcontents


\pagebreak

\section{Implementation of BDI}


\pagebreak



\section{Single-Agent Architecture}


\subsection{Beliefs and Beliefs Revision}


\subsection{Intentions and Intentions Revision}


\subsection{Planning}

This task is implemented into the related and It takes as input all the elements of the beliefset (map, agents and parcels list and the current agent) and, after the intentions are computed it creates the plan that the agent is going to use.
More precisely, the task that the solver have to solve consists into a BFS (Breadth-First Search) that:
\begin{itemize}
    \item Is performed on the game map, considered as an undirected graph, where the cells are the nodes and the proximity to other cells describe the edges
    \item Uses the agent position as root
    \item Ends when the shortest path to the target cell is found\\
\end{itemize}

Tho compute the plan the planner relies on an online PDDL1.2 (Planning Domain Definition Language) online solver. As the standard declare, the model of the planning problem is composed by two major parts:
\begin{enumerate}
    \item Domain description: define the predicates that characterize the environment and the action that can be performed
    \item Problem description: describe objects in the environment, the initial state and goal descriptions that will characterize the current plan\\
\end{enumerate}

\subsubsection{Domain description}

Since the tasks consists of a BFS, the domain file model the environment, composed by cells and the agent, into an undirected graph.
More precisely, the domain is composed by:
\begin{itemize}
    \item Predicates:
    \begin{itemize}
        \item \emph{cell ?x\_y}: it indicates that the object \emph{x\_y} is a cell and a node of our graph
        \item \emph{near ?from\_x\_y ?to\_x\_y}: It models that the cell \emph{from\_x\_y} is near the cell \emph{to\_x\_y}, i.e., there is a unidirectional edge from the first to the second (in the Problem description section is explained how the graph become undirected)
        \item \emph{in ?x\_y}: it keeps track that the agent is in the cell \emph{x\_y}. In the graph parallelism it refers to the node that the planner is visiting
    \end{itemize}
    \item Actions:
    \begin{itemize}
        \item \emph{move}: it represents the agent movement through the map (i.e,, the graph). It takes as parameters two objects \emph{from\_x\_y} and \emph{to\_x\_y}, which respectively represent the starting and the target cell of the movement. Then it checks if the agent is in \emph{from\_x\_y} (i.e., \emph{from\_x\_y}), if the object \emph{to\_x\_y} is a cell (i.e., \emph{cell to\_x\_y}) and if the two cells \emph{from\_x\_y} and \emph{to\_x\_y} are close (i.e., \emph{near from\_x\_y to\_x\_y}).
        After that, the effect of the action consists in moving the agent to the target cell (i.e., \emph{in to\_x\_y}) and making sure that it is different from the starting cell (i.e., \emph{not (in from\_x\_y})
    \end{itemize}
\end{itemize}

In the move action we avoid to put the precondition \emph{cell from\_x\_y} because we assume that the starting point of the plan taken from the intentions is a cell. After that, thanks to the combination of the precondition \emph{cell to\_x\_y} and the effect \emph{in to\_x\_y} we know that all the subsequently objects are cells.

Here is the domain description just described:
\begin{verbatim}
;; domain file: domain.pddl
(define (domain default)
    (:requirements :strips)
    (:predicates
        (cell ?x_y)
        (near ?x_y ?x_y)
        (in ?x_y)
    )
    
    (:action move
        :parameters (?from_x_y ?to_x_y)
        :precondition (and (in ?from_x_y) (cell ?to_x_y) (near ?from_x_y ?to_x_y))
        :effect (and (in ?to_x_y) (not (in ?from_x_y)))
    )
)
\end{verbatim}

\subsubsection{Problem description}

The problem description is created in two different phases.
First of all, when the map is initialized, we visit the matrix and for each cell that isn't a wall we identify it as \emph{c\_x\_y}, where \emph{x} and \emph{y} are its coordinates, and declare (i.e., add the proper objects and put the proper predicate in the \emph{init} section) that it is a cell (i.e., \emph{cell c\_x\_y}) and, for every neighboring cell (identified with the same notation) that is not a wall, we sign that they are close (i.e., \emph{near c\_x\_y c\_\(x_1\)\_\(y_1\)}).
Then, when we have to compute a plan, we look at what cell \emph{c\_x\_y} the other officers are in and we treat each of them as walls (i.e., \emph{(not (cell c\_x\_y))}). After that, we declare in which cell \emph{c\_x\_y} the agent is (i.e., \emph{in c\_x\_y}) and we set the target cell \emph{c\_\(x_1\)\_\(y_1\)}, taken from the intentions as the goal of the plan (i.e., \emph{in c\_\(x_1\)\_\(y_1\)}).\\
These two actions are performed always taking the problem description of the map described before and updating it at the current situation as just described.

\subsubsection{PDDL example}

Consider a situation like this:
%Photo

The problem description is created is as follows:
\begin{verbatim}
(define (problem BFS)
    (:domain deliveroo)
    (:objects c_0_0 c_0_1 c_0_2 c_0_3 c_1_1 c_1_2 c_2_0 c_2_1 c_2_2 c_2_3 c_3_0)
    (:init 
        (cell c_0_0) (cell c_0_1) (cell c_0_2) (cell c_0_3)
        (cell c_1_1) (cell c_1_2)
        (cell c_2_0) (cell c_2_1) (cell c_2_2) (cell c_2_3)
        (cell c_3_0)
        (near c_0_0 c_0_1)
        (near c_0_1 c_0_0) (near c_0_1 c_1_1) (near c_0_1 c_0_2)
        (near c_0_2 c_0_1) (near c_0_2 c_1_2) (near c_0_2 c_0_3)
        (near c_0_3 c_0_2)
        (near c_1_1 c_0_1) (near c_1_1 c_2_1) (near c_1_1 c_1_2)
        (near c_1_2 c_0_2) (near c_1_2 c_1_1) (near c_1_2 c_2_2)
        (near c_2_0 c_3_0) (near c_2_0 c_2_1)
        (near c_2_1 c_1_1) (near c_2_1 c_2_0) (near c_2_1 c_2_2)
        (near c_2_2 c_1_2) (near c_2_2 c_2_1) (near c_2_2 c_2_3)
        (near c_2_3 c_2_2)
        (near c_3_0 c_2_0)
        (in c_0_3))
    (:goal (in c_3_0))
)
\end{verbatim}

And the plan that is created is:
\begin{verbatim}
(move c_0_3 c_0_2) -> down
(move c_0_2 c_1_2) -> right
(move c_1_2 c_2_2) -> right
(move c_2_2 c_2_1) -> down
(move c_2_1 c_2_0) -> down
(move c_2_0 c_3_0) -> right
\end{verbatim}

\subsubsection{Considerations}

After the planner has computed the plan we translate it in the language that the agent can understand. In fact, we parse the coordinates contained into the objects \emph{from\_x\_y} and \emph{to\_x\_y} and compute if the movement corresponds to \emph{up}, \emph{down}, \emph{left} or \emph{right}. After that we append to the plan the intention \emph{pickup} or \emph{putdown} computed before.\\

Anyway, the choice to assign to the planner "only" the BFS task relies on two factors.
\begin{itemize}
    \item The first one is regards the complexity of PDDL solver. In fact, since it is exponential in the number of actions and polynomial in the number of states, reducing the number of actions to only one (the move action) we have reduced the overall complexity. In this way the latency is considerably reduced, since the major complexity of the solver is simplified, and the remaining latency are the one given by the polyomial part of the solver algorithm and the one of the network
    \item The second one take into consideration how the PDDL planner works. Indeed, considering that starting from the starting cell (initial state) and moving through the nearby cells (action move) until it reaches the target cell (goal), the first plan found (i.e, the shortest) coincides with the shortest path bewteen the starting and the target cell
\end{itemize}

\subsubsection{Offline version}

Since the online solver adds a latency due to the network latency we created an offline version of the BFS method that works completely synchronously with the code and reduce considerably the time taken by the planner to compute the plan.

\pagebreak

\section{Multi-Agent Architecture}


\subsection{Communication}


\subsection{Beliefs and Beliefs Revision}


\subsection{Intentions and Intentions Revision}


\subsection{Planning}






\pagebreak

\section{Robe da fare}

Roba da mettere:

Un agente
\begin{itemize}
\item Beliefs implementate
\item Come abbiamo fatto belief revision
\item Le intention che abbiamo considerato (pickup, delivery, idle(search))
\item Implementazione delle intention e intention revision
\item formulazione del plan con il pddl e cenno alla versione BFS
\end{itemize}

Due agenti
\begin{itemize}
\item come abbiamo gestito la comunicazione
\item belief aggiunte rispetto alla versione con un agente solo
\item come facciamo belief revision con la comunicazione per sincronizzare i due agenti
\item Come abbiamo cambiato le intention singole rispetto ad un agente solo (non sceglie il target se è dell'altro agente)
\item le intention e i multi-agent plan che abbiamo aggiunto
\item come abbiamo gestito l'implementazione delle nuove intention
\item anche qua dire sul pddl cosa abbiamo fatto
\end{itemize}

C'è da chiarire la questione dei desire e spiegare che magari noi abbiamo astratto solo le intention. Sarebbe carino fare degli pseudo codici per spiegare il while principale del planner per far vedere come abbiamo effettivamente gestito le cose. Anche potrebbe essere interessante spiegare le funzioni di utility che abbiamo creato, specialmente per la prima parte del progetto.





\pagebreak

\bibliographystyle{abbrv}
% \bibliography{references}  % need to put bibtex references in references.bib
\end{document}